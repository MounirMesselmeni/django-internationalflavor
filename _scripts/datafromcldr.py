from __future__ import absolute_import
import argparse
import json
import os
import zipfile
import django
from django.conf import settings
from django.core.management.base import BaseCommand, CommandError
from _common import COUNTRY_ALTERNATIVE_KEYS


# This is almost a management command, but we do not want it to be added to the django-admin namespace for the simple
# reason that it is not expected to be executed by package users, only by the package maintainers.
# We use a thin __main__ wrapper to make it work (ish) like a management command.


class Command(BaseCommand):
    help = ('Updates localized data of the internationalflavor module using data from the Unicode '
            'Common Locale Data Repository (CLDR)')

    def handle(self, *args, **options):
        MODULE_PATH = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', 'internationalflavor')

        try:
            # Unzip the files
            self.stdout.write("Reading CLDR from %s" % os.path.abspath(options['path_to_cldr']))

            with zipfile.ZipFile(options['path_to_cldr']) as cldr_zip:
                tdata = json.loads(cldr_zip.read(os.path.join("main", "en", "territories.json")).decode("utf8"))
                territories = tdata['main']['en']['localeDisplayNames']['territories']

                tzdata = json.loads(cldr_zip.read(os.path.join("main", "en", "timeZoneNames.json")).decode("utf8"))
                timezones = tzdata['main']['en']['dates']['timeZoneNames']

                with open(os.path.join(MODULE_PATH, "countries", "_cldr_data.py"), 'w') as f:
                    f.write(b"# coding=utf-8\n")
                    f.write(b"# This file is automatically generated based on the English CLDR file.\n")
                    f.write(b"# Do not edit manually.\n\n")
                    f.write(b"from __future__ import unicode_literals\n")
                    f.write(b"from django.utils.translation import ugettext_lazy as _\n\n")
                    f.write(b"COUNTRY_NAMES = {\n")
                    for territory, name in sorted(territories.items()):
                        if len(territory) == 2:
                            if territory in COUNTRY_ALTERNATIVE_KEYS:
                                name = territories[COUNTRY_ALTERNATIVE_KEYS[territory]]
                            f.write(b'    "%s": _("%s"),\n' % (territory.encode('utf8'),
                                                               name.encode('utf8')))
                    f.write(b"}\n")

                with open(os.path.join(MODULE_PATH, "timezone", "_cldr_data.py"), 'w') as f:
                    f.write(b"# coding=utf-8\n")
                    f.write(b"# This file is automatically generated based on the English CLDR file.\n")
                    f.write(b"# Do not edit manually.\n\n")
                    f.write(b"from __future__ import unicode_literals\n")
                    f.write(b"from django.utils.translation import ugettext_lazy as _\n\n")
                    f.write(b"TIMEZONE_NAMES = {\n")

                    # We want to be able to recurse this.
                    def write_tz_info(region_name, region_path, rest):
                        if 'exemplarCity' in rest:
                            city = rest['exemplarCity']

                            # Parse the time zone name
                            if 'long' in rest and 'generic' in rest['long']:
                                tz_name = rest['long']['generic']
                            elif region_path == [u'Etc', u'GMT']:
                                tz_name = timezones['gmtZeroFormat']
                            elif region_path[0] == u'Etc' and region_path[1].startswith(u'GMT'):
                                if region_path[1].startswith(u"GMT-"):
                                    tz_name = timezones['hourFormat'].split(';')[1]
                                    tz_name = tz_name.replace('HH', region_path[1][4:].zfill(2))
                                else:
                                    tz_name = timezones['hourFormat'].split(';')[0]
                                    tz_name = tz_name.replace('HH', region_path[1][3:].zfill(2))
                                tz_name = tz_name.replace('mm', '00')
                                tz_name = timezones['gmtFormat'].format(tz_name)
                            else:
                                tz_name = timezones['regionFormat'].format(city)

                            f.write(b'    "%s": (_("%s"), _("%s"), _("%s")),\n' % ("/".join(region_path).encode('utf8'),
                                                                                   region_name.encode('utf8'),
                                                                                   city.encode('utf8'),
                                                                                   tz_name.encode('utf8')))
                        else:
                            for path, region in sorted(rest.items()):
                                write_tz_info(region_name, region_path + [path], region)

                    for zone, rest in sorted(timezones['zone'].items()):
                        write_tz_info(zone, [zone], rest)
                    f.write(b"}\n")

        except OSError as e:
            raise CommandError("Error while reading zip file: %s" % e)


if __name__ == '__main__':
    settings.configure()
    if hasattr(django, 'setup'):
        django.setup()

    # We parse arguments ourselves. Django 1.8 uses argparse (finally) but we can just as easily use it ourselves.
    parser = argparse.ArgumentParser(description=Command.help)
    parser.add_argument('path_to_cldr', help='Path to a zip file containing CLDR JSON files.')
    args = parser.parse_args()

    Command().execute(**vars(args))